/*
 * MsgInHandler.cpp
 *
 *  Created on: 6. mai 2011
 *      Author: nn
 */

#include "MsgInHandler.h"
#include <iostream>
#include <string.h>
#include <pthread.h>

//#include "skipper.h"
#include "NmeaComm.h"
#include "protocol/BinaryEchoParser.h"
#include "protocol/NewEchoParser.h"

#include "comm/Dispatcher.h"

#include "data/DataProcessing.h"
#include "data/ButterworthLowPassFilter.h"

#include "utility/NmeaParser.h"
#include "utility/CurtisFormatParser.h"
#include "utility/NmeaMsgCreator.h"

#include "utility/SignalGenerator.h"
#include "utility/ESignal.h"
#include "utility/EByteArray.h"
#include "data/Data.h"



///////////hei Ernad /////////
MsgInHandler* thisInstance;
pthread_mutex_t lastMsgMutex;

int nRange;
int nGain = 1;

bool serialPort3Running = false;
int com3baudRate = 4800; //TODO: get from config

void * runCom3listener(void *ptr);

MsgInHandler::MsgInHandler() {
	memset(lastMsgStream_1, 0, 17000);
	memset(lastMsgStream_2, 0, 17000);
	nNoOfMessages = 0;
	nNextMsgPos = 0;
	thisInstance = this;
	nRange = 0;
	nStram_1_length = 0;
	nStram_2_length = 0;

	totalReceived = 0;

	//nForwardNmeaMsgsSource = -1;
}

MsgInHandler::~MsgInHandler() {

}

MsgInHandler* MsgInHandler::getInstance() {
	return thisInstance;
}

void MsgInHandler::getLastXXMessage(char* pStream) {

}

void MsgInHandler::getLastWeatherMessage(char* pStream) {
	strcpy(pStream, lastMsgStream_2);
}
/*
void MsgInHandler::setRange(int newRange) {
	nRange = newRange;
}

void MsgInHandler::setGain(int newGain) {
	nGain = newGain;
}
*/
bool MsgInHandler::getLastEchoMessage(char* pStream) {
	pthread_mutex_lock(&lastMsgMutex);
	if (lastMsgStream_1[0] != 0) {
		strcpy(pStream, lastMsgStream_1);
		lastMsgStream_1[0] = 0;
		//nNoOfMessages = 0;
		//nNextMsgPos = 0;
		pthread_mutex_unlock(&lastMsgMutex);
		return true;
	} else {
		pthread_mutex_unlock(&lastMsgMutex);
		return false;
	}
}

bool MsgInHandler::changeBaudRate_serial3(int newBaud) {
	/*printf("************************************************\n");
	printf("***       RESTART SERIAL PORT 3 (ttyS2)?    ****\n");
	printf("************************************************\n");
	serialPort3.closeSerial();
	com3baudRate = newBaud;

	while(serialPort3Running){ //TODO: if never false?
		usleep(10000); // sleep 10 ms
	}
	pthread_create(&threadCom3,   NULL, runCom3listener, (void*) this);*/
	return true;
}
/*
void MsgInHandler::onReceivedNewDisplayChoice(int nSource, int selectedChoice) {
	printf("************************************************\n");
	printf("***       SOURCE: %d, choice: %d     ****\n", nSource, selectedChoice);
	printf("************************************************\n");

	if (selectedChoice == 1) { // Selected "IN"
		Data::setForwardSourceIndex(nSource);
		//nForwardNmeaMsgsSource = nSource;
	} else {					 // Selected "OUT" (0) or "OFF" (2)
		Data::setForwardSourceIndex(-1);
		//nForwardNmeaMsgsSource = -1;
	}
}*/


void * runCom3listener(void *ptr) {
	char buffer[10024]; // Storage of NMEA data stream
	SerialCom* pserialPort3 = &((MsgInHandler*)ptr)->serialPort3;
	int nRec;

	pserialPort3->openSerial("/dev/ttyS2", com3baudRate);

	NmeaParser nmeaParser;
	nmeaParser.init(3); // COM 3

	serialPort3Running = true;

	for (;;) {
		nRec = pserialPort3->receiveSerial(buffer, 10024);

		if (nRec > 0) {
			nmeaParser.addChars(buffer, nRec); // SIGNAL AUTOGENERATED FROM NmeaParser if message is completed.
			//circularBuffer.addChars(buffer, nRec); // todo: if > 0
			//int nMsgSize = circularBuffer.getMessage('$', '*', nmeaMsgBuff);
		} else if (nRec == 0){
			printf("***************nREC = 0\n");
		} else {
			printf("************************************************\n");
			printf("***  REC < 0, CLOSED SERIAL PORT 3 (ttyS2)? ****\n");
			printf("************************************************\n");
			serialPort3Running = false;
			return 0;
		}
	}

	return 0;
}

void * runCurtisReceivingThread(void *ptr);

void * runCurtisReceivingThread(void *ptr) {
	char buffer[8000];
	SerialCom serialPortEcholodd;
	int nRec;

	CurtisFormatParser curtisFormatParser;
	curtisFormatParser.init(1);


	serialPortEcholodd.openSerial("/dev/ttyS1", 115200);

	for (;;) {
		nRec = serialPortEcholodd.receiveSerial(buffer, 8000);

		if (nRec > 0) {
			curtisFormatParser.addChars(buffer, nRec);
		}
	}
	return 0;
}

void MsgInHandler::runHandler() {
	NmeaComm stream1;
	NmeaComm stream2;
	char nmeaAsciBuffer[17000];
	char nmeaOutBuffer[1000];

	int nmeaAsciBufferLength;


	SignalGenerator* signalGenerator = SignalGenerator::getInstance(0);
	ESignal* eSignal;
	EByteArray* eByteArray;

	int ret;
	ret = pthread_create(&threadCurtis, NULL, runCurtisReceivingThread, (void*) this);
	ret = pthread_create(&threadCom3,   NULL, runCom3listener,          (void*) this);

	for (;;) {
		eSignal = signalGenerator->waitOnSignal();
		if (eSignal != NULL) {
			if (eSignal->signalType == 1) {
				eByteArray = (EByteArray*) eSignal->msg;
				//DataProcessing::kalmanFilter(pBuffer, 400, outArray);
				// ButterworthLowPassFilter::test(outArray, 400, outArray);
				int nButtom = DataProcessing::bottomDetection(
						&eByteArray->data()[1], 400);
				NewEchoParser::convertDataToAsciNmea(nButtom, nRange, nGain,
						&eByteArray->data()[1], 400, nmeaAsciBuffer,
						&nmeaAsciBufferLength);

				//NmeaMsgCreator::getDptMsgBuffer(nmeaOutBuffer, (float)nButtom, true, 0.f, false, 0.f, false);
				//Data::getInstance()->setNmeaMsg(nmeaOutBuffer);

				//BinaryEchoParser::convertCompressedDataToAsciNmea(nRange, pBuffer, length, lastMsgStream_1, &nStram_1_length);

				Dispatcher::sendEchoMsg(nmeaAsciBuffer, nmeaAsciBufferLength);

			} else if (eSignal->signalType == 2) {
				eByteArray = (EByteArray*) eSignal->msg;
				eByteArray->data()[eByteArray->length() - 1] = 0;
				printf("COM 3, NMEA: %s\n", eByteArray->data());

				if(Data::getActiveDisplayIndex() == 2 && Data::getDisplayIoChoice() == 1)
					Data::getInstance()->setNmeaMsg(eByteArray->data());
			} else if (eSignal->signalType == 3) {
				eByteArray = (EByteArray*) eSignal->msg;
				eByteArray->data()[eByteArray->length() - 1] = 0;
				printf("COM 3, NMEA: %s\n", eByteArray->data());

				if(Data::getActiveDisplayIndex() == 3 && Data::getDisplayIoChoice() == 1)
					Data::getInstance()->setNmeaMsg(eByteArray->data());
			}
		}
	}
	//	serialPortEcholodd.closeInputPort();
	//serialPortEcholodd.closeOutputPort();
}
