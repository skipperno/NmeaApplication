/*
 * MsgInHandler.cpp
 *
 *  Created on: 6. mai 2011
 *      Author: nn
 */

#include "MsgInHandler.h"
#include <iostream>
#include <string.h>
#include <pthread.h>

//#include "skipper.h"
#include "NmeaComm.h"
#include "protocol/BinaryEchoParser.h"
#include "protocol/NewEchoParser.h"

#include "comm/Dispatcher.h"

#include "data/DataProcessing.h"
#include "data/ButterworthLowPassFilter.h"

#include "utility/NmeaParser.h"
#include "utility/CurtisFormatParser.h"
#include "utility/NmeaMsgCreator.h"

#include "utility/SignalGenerator.h"
#include "utility/ESignal.h"
#include "utility/EByteArray.h"
#include "data/Data.h"

#include "webserver/EchoDataWebSocket.h"

///////////hei Ernad /////////
MsgInHandler* thisInstance;
pthread_mutex_t lastMsgMutex;

int nRange;
int nGain = 1;

bool serialPort3Running = false;
int com3baudRate = 4800; //TODO: get from config

void * runCom3listener(void *ptr);

MsgInHandler::MsgInHandler() {
	memset(lastMsgStream_1, 0, 17000);
	memset(lastMsgStream_2, 0, 17000);
	nNoOfMessages = 0;
	nNextMsgPos = 0;
	thisInstance = this;
	nRange = 0;
	nStram_1_length = 0;
	nStram_2_length = 0;

	totalReceived = 0;

	//nForwardNmeaMsgsSource = -1;
}

MsgInHandler::~MsgInHandler() {

}

MsgInHandler* MsgInHandler::getInstance() {
	return thisInstance;
}

void MsgInHandler::getLastXXMessage(char* pStream) {

}

void MsgInHandler::getLastWeatherMessage(char* pStream) {
	strcpy(pStream, lastMsgStream_2);
}
/*
void MsgInHandler::setRange(int newRange) {
	nRange = newRange;
}

void MsgInHandler::setGain(int newGain) {
	nGain = newGain;
}
*/
bool MsgInHandler::getLastEchoMessage(char* pStream) {
	pthread_mutex_lock(&lastMsgMutex);
	if (lastMsgStream_1[0] != 0) {
		strcpy(pStream, lastMsgStream_1);
		lastMsgStream_1[0] = 0;
		//nNoOfMessages = 0;
		//nNextMsgPos = 0;
		pthread_mutex_unlock(&lastMsgMutex);
		return true;
	} else {
		pthread_mutex_unlock(&lastMsgMutex);
		return false;
	}
}

bool MsgInHandler::changeBaudRate_serial3(int newBaud) {
	return true;
	printf("************************************************\n");
	printf("***       RESTART SERIAL PORT 3 (ttyS2)?    ****\n");
	printf("************************************************\n");
	serialPort3.closeSerial();
	com3baudRate = newBaud;
printf("Wait\n");
	while(serialPort3Running){ //TODO: if never false?
		usleep(10000); // sleep 10 ms
	}
	printf("Wait end. Create new thread\n");
	usleep(100000);
	pthread_create(&threadCom3,   NULL, runCom3listener, (void*) this);
	printf("Wait end. Create new thread\n");
	return true;
}

int MsgInHandler::sendMsgSerial1 (const char* pBuffer, int length) {
	//return serialPort1.sendSerial(pBuffer, length);
	return 0;
}
int MsgInHandler::sendMsgSerial2 (const char* pBuffer, int length) {
	//return serialPort2.sendSerial(pBuffer, length);
	return 0;
}
int MsgInHandler::sendMsgSerial3 (const char* pBuffer, int length) {
	return serialPort3.sendSerial(pBuffer, length);
}

int MsgInHandler::selfTest(int on_off, int source){
	if (on_off == 1) {
		selftest.startTest(source);
	} else {
		selftest.stopTest();
	}

	return 0;
}

/*
void MsgInHandler::onReceivedNewDisplayChoice(int nSource, int selectedChoice) {
	printf("************************************************\n");
	printf("***       SOURCE: %d, choice: %d     ****\n", nSource, selectedChoice);
	printf("************************************************\n");

	if (selectedChoice == 1) { // Selected "IN"
		Data::setForwardSourceIndex(nSource);
		//nForwardNmeaMsgsSource = nSource;
	} else {					 // Selected "OUT" (0) or "OFF" (2)
		Data::setForwardSourceIndex(-1);
		//nForwardNmeaMsgsSource = -1;
	}
}*/


void * runCom3listener(void *ptr) {
	char buffer[10024]; // Storage of NMEA data stream
	SerialCom* pserialPort3 = &((MsgInHandler*)ptr)->serialPort3;
	int nRec;

	pserialPort3->openSerial("/dev/ttyS2", com3baudRate);

	NmeaParser nmeaParser;
	nmeaParser.init(3); // COM 3

	serialPort3Running = true;

	for (;;) {
		nRec = pserialPort3->receiveSerial(buffer, 10024);

		if (nRec > 0) {
			nmeaParser.addChars(buffer, nRec); // SIGNAL AUTOGENERATED FROM NmeaParser if message is completed.
			//circularBuffer.addChars(buffer, nRec); // todo: if > 0
			//int nMsgSize = circularBuffer.getMessage('$', '*', nmeaMsgBuff);
		} else if (nRec == 0){
			printf("***************nREC = 0\n");
		} else {
			printf("************************************************\n");
			printf("***  REC < 0, CLOSED SERIAL PORT 3 (ttyS2)? ****\n");
			printf("************************************************\n");
			serialPort3Running = false;
			return 0;
		}
	}

	return 0;
}

void * runCurtisReceivingThread(void *ptr);

void * runCurtisReceivingThread(void *ptr) {
	char buffer[8000];
	SerialCom serialPortEcholodd;
	int nRec;

	CurtisFormatParser curtisFormatParser;
	curtisFormatParser.init(1);


	serialPortEcholodd.openSerial("/dev/ttyS1", 115200);

	for (;;) {
		nRec = serialPortEcholodd.receiveSerial(buffer, 8000);

		if (nRec > 0) {
			curtisFormatParser.addChars(buffer, nRec);
		}
	}
	return 0;
}

void MsgInHandler::runHandler() {
	NmeaComm stream1;
	NmeaComm stream2;
	char nmeaAsciBuffer[17000];
	//char nmeaOutBuffer[1000];
	char tempBuf[500];
	int nmeaAsciBufferLength;


	SignalGenerator* signalGenerator = SignalGenerator::getInstance(0);
	ESignal* eSignal;
	EByteArray* eByteArray;

	int ret;
	ret = pthread_create(&threadCurtis, NULL, runCurtisReceivingThread, (void*) this);
	ret = pthread_create(&threadCom3,   NULL, runCom3listener,          (void*) this);

	for (;;) {
		eSignal = signalGenerator->waitOnSignal();
		if (eSignal != NULL) {
			if (eSignal->signalType == 1) { // Curtis data received
				eByteArray = (EByteArray*) eSignal->msg;
				 DataProcessing::kalmanFilter(&eByteArray->data()[1], 400, tempBuf);
				//ButterworthLowPassFilter::test(&eByteArray->data()[1], 400, &eByteArray->data()[1]);
				/*int nButtom = DataProcessing::bottomDetection(
						&eByteArray->data()[1], 400);*/
				int nButtom = DataProcessing::bottomDetection(
						tempBuf, 400);
				NewEchoParser::convertDataToAsciNmea(nButtom, Data::getInstance()->getRange(), nGain,
						tempBuf, 400, nmeaAsciBuffer,//&eByteArray->data()[1], 400, nmeaAsciBuffer,
						&nmeaAsciBufferLength);

				EchoDataWebSocket::broadcastMsgToClients(nmeaAsciBuffer, nmeaAsciBufferLength);

				//BinaryEchoParser::convertCompressedDataToAsciNmea(nRange, pBuffer, length, lastMsgStream_1, &nStram_1_length);


				//Dispatcher::sendEchoMsg(nmeaAsciBuffer, nmeaAsciBufferLength);

			} else if (eSignal->signalType == 2) { // Msg from COM 2
				eByteArray = (EByteArray*) eSignal->msg;
				eByteArray->data()[eByteArray->length() - 1] = 0;
				printf("COM 2, NMEA: %s\n", eByteArray->data());

				if(Data::getActiveDisplayIndex() == 2 && Data::getDisplayIoChoice() == 1)
					Data::getInstance()->sendNmeaMsg(eByteArray->data(), NMEA_DIRECT_IN);
			} else if (eSignal->signalType == 3) { // Msg from COM 3
				eByteArray = (EByteArray*) eSignal->msg;
				eByteArray->data()[eByteArray->length() - 1] = 0;
				printf("COM 3, Received NMEA: %s\n", eByteArray->data());

				if(Data::getActiveDisplayIndex() == 3 && Data::getDisplayIoChoice() == 1) {
					Data::getInstance()->sendNmeaMsg(eByteArray->data(), NMEA_DIRECT_IN);
					printf("sent nmea\n");
				} else {
					printf("Not sent, active display: %d, IO choice: %d\n", Data::getActiveDisplayIndex(), Data::getDisplayIoChoice());
				}
			}
		}
	}
	//	serialPortEcholodd.closeInputPort();
	//serialPortEcholodd.closeOutputPort();
}
